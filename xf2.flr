// XF2 - Explained Flora-2
// By Jason Morris for Singapore Management University Centre for Computational Law
//
// TO DO:
// * The display method is displaying the same messages multiple times.
// * Right now the display method on the explanation objects runs only once.
//   There is documentation in the ErgoAI documentation google folder that shows
//   how to make it run repeatedly.
// * Need to get negations working. Not sure how to parse lists associated with them.

:- compiler_options{expert=on}.

// The following code sets out a tree structure for explanations to be built inside.

xf2Explanation[|
    goal=>\symbol,
    subgoals=>xf2Explanation,
    satisfied=>\boolean,
    desc=>\string|].

?x[display] :-
  ?x:xf2Explanation,
  ?x[display(0)].

?x[display(?n)] :-
  ?x:xf2Explanation[desc->?d,goal->?g,satisfied->?s],
  tab(?n)@\prolog,
  write('Goal: ')@\io,
  write(?g)@\io,
  \if ?s \then write(' is satisfied.\n')@\io \else write(' is not satisfied.\n')@\io,
  tab(?n)@\prolog,
  write(?d)@\io,
  write('\n')@\io,
  ?o \is ?n+1,
  forall(?subs)^(?x[subgoals->?subs] ~~> ?subs[display(?o)]),
  !.

xf2Bool::xf2Explanation.
xf2Conjunction::xf2Explanation.
xf2Disjunction::xf2Explanation.
xf2Negation::xf2Explanation.
xf2BaseFact::xf2Explanation.
xf2Rule::xf2Explanation.

// debugging(on).

// If the goal of an explanation is "\true", it is satisfied,
// because true is always true.
?x:xf2Bool[satisfied->\true,desc->'True is self-evident.'] :-
  ?x:xf2Explanation[goal->\true],
  \if debugging(on) \then write('Found \\true goal, set to satisfied.\n')@\io.

// If the goal of an explanation is "\false", it is not satisfied,
// because false is always false.
?x:xf2Bool[satisfied->\false,desc->'False is self-evident.'] :-
  ?x:xf2Explanation[goal->\false],
  \if debugging(on) \then write('Found \\false goal, set to satisfied.\n')@\io.

// If the goal is provided by the user, it is a basefact, and is
// satisfied.
?x:xf2BaseFact[satisfied->\true,desc->'Answer was provided by user.'] :-
  ?x:xf2Explanation[goal->?goal],
  isbasefact{?goal},
  \if debugging(on) \then write('Found basefact goal, set to satisfied.\n')@\io.

// If there is a rule explanation, whether it is satisfied depends on
// whether the rulebody is satisfied.
?x[satisfied->?sat] :-
  ?x:xf2Rule[subgoals->?_[satisfied->?sat]],
  \if debugging(on) \then write('Setting satisfaction of rule.\n')@\io.

// If the goal is the conclusion of a rule, there is a node for the
// rule with one sub-node for the body.
?x:xf2Rule[desc->'There is a rule.', subgoals->subgoal(?x,?body):xf2Explanation[goal->?body]] :-
  ?x:xf2Explanation[goal->?goal],
  clause{?goal, ?body},
  \if debugging(on) \then write('Adding a body node to a rule.\n')@\io.

// If the goal is a negation, it is satisfied if the negation is true.
?x:xf2Negation[satisfied->\true, desc->'Negation.'] :-
  //write('Checking for true negation.\n')@\io,
  ?x:xf2Explanation[goal->?goal],
  ?goal =.. [?g1|?g2],
  //write(?g1)@\io, nl@\prolog, write(?g2)@\io, nl@\prolog,
  ?g1 == negation(naf), // This is not working because the structure is {negation(naf),[${queries}]}?
  \true, // Just for debugging purposes.
  \if debugging(on) \then write('Pretending to find successful negation.\n')@\io.


// If the goal is a negation, it is not satisfied if the goal is true.
?x:xf2Negation[satisfied->\false, desc->'Negation.'] :-
  //write('Checking for false negation.\n')@\io,
  ?x:xf2Explanation[goal->?goal],
  ?goal =.. [?g1|?g2],
  ?g1 == negation(naf),
  \false, // Just for debugging purposes.
  \if debugging(on) \then write('Pretending to find unsuccessful negation.\n')@\io.

// If the goal is a conjunction, there is a subgoal for each of the parts of the second half.
?x:xf2Conjunction[desc->'Conjunction.',subgoals->subgoal(?goal,?g3):xf2Explanation[goal->?g3]] :-
  ?x:xf2Explanation[goal->?goal],
  ?goal =.. [?g1|?g2],
  ?g1 == logic(and),
  ?g3 \in ?g2, // There is a list, and this rule should unify with all of the members.
  \if debugging(on) \then write('Adding a subgoal to a conjunction.\n')@\io.

// If the goal is a conjunction, and all of the subgoals are satisfied, the goal is satisfied.
?x[satisfied->\true] :-
  ?x:xf2Conjunction,
  forall(?subs)^(?x[subgoals->?subs] ~~> ?subs[satisfied->\true]),
  \if debugging(on) \then write('Finding a satisfied conjunction.\n')@\io.

// If the goal is a conjunction, and not all of the subgoals are satisfied, the goal is not satisfied.
?x[satisfied->\false] :-
  ?x:xf2Conjunction,
  ?x[subgoals->?_[satisfied->\false]],
  \if debugging(on) \then write('Finding an unsatisfied conjunction.\n')@\io.

// If the goal is a disjunction, there is a subgoal for each of the parts of the second half.
?x:xf2Disjunction[desc->'Disjunction.',subgoals->subgoal(?goal,?g3):xf2Explanation[goal->?g3]] :-
  ?x:xf2Explanation[goal->?goal],
  ?goal =.. [?g1|?g2],
  ?g1 == logic(or),
  ?g3 \in ?g2, // There is a list, and this rule should unify with all of the members.
  \if debugging(on) \then write('Adding a subgoal to a disjunction.\n')@\io.

// If the goal is a disjunction, and any of the subgoals are satisfied, the goal is satisfied.
?x[satisfied->\true] :-
  ?x:xf2Disjunction,
  ?x[subgoals->?_[satisfied->\true]],
  \if debugging(on) \then write('Finding a satisfied disjunction.\n')@\io.

// If the goal is a disjunction, and all of the subgoals are not satisfied, the goal is not satisfied.
?x[satisfied->\false] :-
  ?x:xf2Disjunction,
  forall(?subs)^(?x[subgoals->?subs] ~~> ?subs[satisfied->\false]),
  \if debugging(on) \then write('Finding an unsatisfied disjunction.\n')@\io.
  

// explain(?Goal) :-
//   clause{@!{?_Tag[source->?SRC,description->?DSC]} ?Goal,?Body},
//    fmt_write('According to %S, %S.\n',args(?SRC,?DSC))@\io,
//    fmt_write('%S can be proven if %S can be proven.\n',args(?Goal,?Body))@\io,
//    explain(?Body).


// Tests

test:xf2Explanation[goal->\true]. // Note that \true and ${\true} work identically.
test2:xf2Explanation[goal->\false].

yummy(apples).

test3:xf2Explanation[goal->${yummy(apples)}]. // Note that this does not work without reification.

wet(road) :- raining.
raining.

test4:xf2Explanation[goal->${wet(road)}].

test5:xf2Explanation[goal->${\naf yummy(pears)}]. // This test is not working.

t6a :-
  yummy(apples),
  wet(road).
t6b :-
  yummy(apples),
  \false.

test6a:xf2Explanation[goal->${t6a}].
test6b:xf2Explanation[goal->${t6b}].